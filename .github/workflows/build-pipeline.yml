# AIDE Cross-Platform Build & Deploy Pipeline
#
# This workflow is now ACTIVE. It will run automatically on pushes and pull requests to the main branch.

name: AIDE Cross-Platform Build

on:
  workflow_dispatch: # Allows manual triggering of the workflow
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

# Grant write permissions for contents (to push to branches) and packages (for GHCR).
permissions:
  contents: write
  packages: write

jobs:
  # Job 0: Run linting and type-checking first. This is a quality gate.
  lint:
    name: Lint & Type-Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate package-lock.json
        run: npm install --package-lock-only --ignore-scripts

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm install

      # Run the lint script, which performs a TypeScript type check without emitting files.
      - name: Run linter
        run: npm run lint

  # Job 1: Build the core web assets. This job is the foundation for all subsequent parallel builds.
  build_web:
    name: Build Web Assets
    needs: lint # This job will only run if the 'lint' job succeeds.
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate package-lock.json
        run: npm install --package-lock-only --ignore-scripts

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm install

      # This step builds the static web app into the 'www' directory, which is Capacitor's web asset source.
      - name: Build web assets
        run: npm run build:web
        env:
          # The bundler needs the API key to embed it in the final code for the client.
          # You MUST set this as a secret in your repository settings.
          API_KEY: ${{ secrets.API_KEY_PLACEHOLDER }}

      # Upload the 'www' directory as an artifact so that other, parallel jobs can download and use it.
      - name: Upload web assets artifact
        uses: actions/upload-artifact@v4
        with:
          name: web-assets
          path: www

  # Job 2: Build the Docker image. This runs in parallel with other platform builds.
  build_docker:
    name: Build Docker Image
    needs: build_web # Depends on the web assets being built first.
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download web assets artifact
        uses: actions/download-artifact@v4
        with:
          name: web-assets
          path: www

      - name: Set repository name to lowercase
        run: echo "repo_lc=$(echo ${{ github.repository }} | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: Log in to the GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.json
          push: true
          tags: ghcr.io/${{ env.repo_lc }}:${{ github.sha }}

  # Job 3: Build desktop executables for Windows, macOS, and Linux using a matrix strategy for parallel builds.
  build_desktop:
    name: Build Desktop App (${{ matrix.os }})
    needs: build_web # This job can't start until the web assets are ready.
    if: github.event_name == 'workflow_dispatch' # This job will only run on manual triggers.
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate package-lock.json
        run: npm install --package-lock-only --ignore-scripts

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm install

      # Download the web assets that were built and uploaded in the previous job.
      - name: Download web assets artifact
        uses: actions/download-artifact@v4
        with:
          name: web-assets
          path: www # Electron is configured to look in 'www' for the index.html file.

      # Run the correct build script based on the runner's operating system.
      - name: Build Electron app for Linux
        if: matrix.os == 'ubuntu-latest'
        run: npm run build:linux

      - name: Build Electron app for Windows
        if: matrix.os == 'windows-latest'
        run: npm run build:win

      - name: Build Electron app for macOS
        if: matrix.os == 'macos-latest'
        run: npm run build:macos
        env:
          # macOS builds require code signing for distribution. Add these secrets to your repository.
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

      - name: Push Desktop Artifact to Branch
        shell: bash
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'actions@github.com'
          
          OS_NAME=${{ matrix.os }}
          BRANCH_NAME="dev-builds/desktop-${OS_NAME}"
          
          # Find the artifact file
          ARTIFACT_PATH=$(find dist -maxdepth 1 -type f \( -name "*.exe" -o -name "*.dmg" -o -name "*.AppImage" \))
          if [ -z "$ARTIFACT_PATH" ]; then
            echo "Error: No build artifact found in dist/ directory."
            exit 1
          fi
          echo "Found artifact: $ARTIFACT_PATH"
          
          ARTIFACT_FILENAME=$(basename "$ARTIFACT_PATH")
          
          # Secure the artifact by moving it out of the repo
          mv "$ARTIFACT_PATH" "/tmp/$ARTIFACT_FILENAME"
          
          # Create a new, clean branch
          git checkout --orphan "$BRANCH_NAME"
          
          # Clean the working directory completely
          git rm -rf .
          git clean -fdx
          
          # Bring the artifact back, commit, and force-push
          mv "/tmp/$ARTIFACT_FILENAME" .
          git add "$ARTIFACT_FILENAME"
          git commit -m "Desktop build for ${{ matrix.os }} from commit ${{ github.sha }}"
          git push --force origin "$BRANCH_NAME"

  # Job 4: Build the native Android App Bundle (AAB) or a fallback APK.
  build_android_appbundle:
    name: Build Android App (AAB/APK)
    needs: build_web
    runs-on: ubuntu-latest
    env:
      SIGNING_KEY_PRESENT: ${{ secrets.ENCODED_SIGNING_KEY != '' }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate package-lock.json
        run: npm install --package-lock-only --ignore-scripts

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Set up Java and Android SDK
        uses: actions/setup-java@v4
        with:
          distribution: 'zulu'
          java-version: '21'
          
      - name: Fetch Last Version
        id: fetch_version
        run: |
          git fetch --all
          if git show-ref --verify --quiet refs/remotes/origin/version-tracker; then
            LAST_VERSION=$(git show origin/version-tracker:VERSION)
          else
            echo "version-tracker branch not found. This must be the first build."
            LAST_VERSION="0.99"
          fi
          echo "Last version was: $LAST_VERSION"
          echo "last_version=$LAST_VERSION" >> $GITHUB_OUTPUT

      - name: Calculate New Version
        id: calc_version
        run: |
          LAST_VERSION=${{ steps.fetch_version.outputs.last_version }}
          NEW_VERSION=$(awk "BEGIN {printf \"%.2f\", ${LAST_VERSION} + 0.01}")
          echo "New version name: $NEW_VERSION"
          MAJOR=$(echo $NEW_VERSION | cut -d. -f1)
          MINOR=$(echo $NEW_VERSION | cut -d. -f2)
          MINOR_INT=$((10#$MINOR))
          NEW_VERSION_CODE=$((MAJOR * 100 + MINOR_INT))
          echo "New version code: $NEW_VERSION_CODE"
          
          echo "version_name=$NEW_VERSION" >> $GITHUB_ENV
          echo "version_code=$NEW_VERSION_CODE" >> $GITHUB_ENV

      - name: Update and Push Version File
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'actions@github.com'
          
          TEMP_DIR=$(mktemp -d)
          cd $TEMP_DIR
          git init
          git remote add origin https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
          
          echo "${{ env.version_name }}" > VERSION
          git add VERSION
          git commit -m "Bump version to ${{ env.version_name }}"
          git push --force origin HEAD:refs/heads/version-tracker

      - name: Install dependencies
        run: npm install
      - name: Download web assets artifact
        uses: actions/download-artifact@v4
        with:
          name: web-assets
          path: www

      - name: Add Capacitor Android platform
        run: npx capacitor add android

      - name: Inject native plugin source files
        run: npm run inject:native

      - name: Sync Capacitor project (discovers plugin)
        run: npx capacitor sync android

      - name: Configure native project (manifests/gradle)
        run: npm run configure:project
        
      - name: Make gradlew executable
        run: chmod +x android/gradlew

      - name: Decode Android Keystore
        if: env.SIGNING_KEY_PRESENT == 'true'
        run: echo "${{ secrets.ENCODED_SIGNING_KEY }}" | base64 --decode > android/upload-keystore.jks

      - name: Create Keystore Properties File
        if: env.SIGNING_KEY_PRESENT == 'true'
        run: |
          echo "storeFile=upload-keystore.jks" > android/keystore.properties
          echo "storePassword=${{ secrets.SIGNING_KEY_STORE_PASSWORD }}" >> android/keystore.properties
          echo "keyAlias=${{ secrets.SIGNING_KEY_ALIAS }}" >> android/keystore.properties
          echo "keyPassword=${{ secrets.SIGNING_KEY_PASSWORD }}" >> android/keystore.properties
      
      - name: Verify Keystore Expiration (Pre-Build Check)
        if: env.SIGNING_KEY_PRESENT == 'true'
        run: |
          echo "Verifying signing certificate..."
          KEYSTORE_PATH="${{ github.workspace }}/android/upload-keystore.jks"

          echo "1. Checking if keystore file exists at $KEYSTORE_PATH..."
          if [ ! -f "$KEYSTORE_PATH" ]; then
            echo "::error::Keystore file not found at the expected path. The 'Decode Android Keystore' step may have failed."
            exit 1
          fi
          echo "Keystore file found."

          echo "2. Running keytool to extract certificate details..."
          # Force locale to C to ensure consistent, non-localized output from keytool
          KEYTOOL_OUTPUT=$(LANG=C keytool -list -v -keystore "$KEYSTORE_PATH" -storepass "${{ secrets.SIGNING_KEY_STORE_PASSWORD }}" -alias "${{ secrets.SIGNING_KEY_ALIAS }}" 2>&1)
          KEYTOOL_EXIT_CODE=$?

          if [ $KEYTOOL_EXIT_CODE -ne 0 ]; then
            echo "::error::keytool command failed with exit code $KEYTOOL_EXIT_CODE."
            echo "keytool output:"
            echo "$KEYTOOL_OUTPUT"
            exit 1
          fi
          echo "keytool command executed successfully."
          
          echo "3. Grepping for validity line..."
          # Find the line containing validity info, which is more robust than a fixed string.
          VALIDITY_LINE=$(echo "$KEYTOOL_OUTPUT" | grep 'Valid from:')
          if [ -z "$VALIDITY_LINE" ]; then
            echo "::error::Could not find 'Valid from:' line in keytool output. The alias, password, or keystore format might be incorrect."
            echo "Full keytool output:"
            echo "$KEYTOOL_OUTPUT"
            exit 1
          fi
          echo "Found line: $VALIDITY_LINE"

          echo "4. Extracting date part from string..."
          # Extract the date part after the "until:" string. This is more robust.
          EXP_DATE=$(echo "$VALIDITY_LINE" | sed 's/.*until: //')
          if [ -z "$EXP_DATE" ]; then
            echo "::error::Failed to extract date from the validity line using sed."
            exit 1
          fi
          echo "Extracted date string: '$EXP_DATE'"
          
          echo "5. Parsing date string with 'date' command..."
          EXP_DATE_EPOCH=$(date -d "$EXP_DATE" +%s)
          DATE_EXIT_CODE=$?

          if [ $DATE_EXIT_CODE -ne 0 ]; then
              echo "::error::The 'date' command failed to parse the expiration date string: '$EXP_DATE'. This might be a locale or date format issue on the runner."
              exit 1
          fi
          echo "Date parsed successfully."

          CURRENT_DATE_EPOCH=$(date +%s)
          
          if [ "$EXP_DATE_EPOCH" -lt "$CURRENT_DATE_EPOCH" ]; then
            echo "::error::Android signing key has EXPIRED on $EXP_DATE. Please generate a new key."
            exit 1
          else
            echo "SUCCESS: Certificate is valid until $EXP_DATE. Proceeding with build."
          fi

      - name: Build Android Release AAB
        if: env.SIGNING_KEY_PRESENT == 'true'
        id: build_aab
        run: cd android && ./gradlew bundleRelease -PenvVersionName=${{ env.version_name }} -PenvVersionCode=${{ env.version_code }}

      - name: Verify AAB Signature (Post-Build Check)
        if: env.SIGNING_KEY_PRESENT == 'true' && steps.build_aab.outcome == 'success'
        run: |
          echo "1. Locating 'apksigner' tool..."
          APKSIGNER_PATH=$(find $ANDROID_HOME/build-tools -name apksigner | sort -r | head -n 1)
          if [ ! -x "$APKSIGNER_PATH" ]; then
            echo "::error::apksigner tool not found or is not executable in Android SDK build-tools."
            echo "Searched in: $ANDROID_HOME/build-tools"
            exit 1
          fi
          echo "Found apksigner at: $APKSIGNER_PATH"

          echo "2. Locating AAB file..."
          AAB_FILE="${{ github.workspace }}/android/app/build/outputs/bundle/release/app-release.aab"
          if [ ! -f "$AAB_FILE" ]; then
              echo "::error::Android App Bundle (AAB) file not found at the expected path: $AAB_FILE"
              exit 1
          fi
          echo "Found AAB file: $AAB_FILE"
          
          echo "3. Verifying AAB signature..."
          if VERIFY_OUTPUT=$($APKSIGNER_PATH verify --print-certs "$AAB_FILE" 2>&1); then
            echo "apksigner output:"
            echo "$VERIFY_OUTPUT"
            echo "SUCCESS: AAB signature is valid."
          else
            VERIFY_EXIT_CODE=$?
            echo "::error::AAB signature verification failed with exit code $VERIFY_EXIT_CODE."
            echo "apksigner output:"
            echo "$VERIFY_OUTPUT"
            exit 1
          fi

      - name: Build Android Debug APK (Fallback)
        if: env.SIGNING_KEY_PRESENT == 'false'
        id: build_apk
        run: cd android && ./gradlew assembleDebug -PenvVersionName=${{ env.version_name }} -PenvVersionCode=${{ env.version_code }}

      - name: Push Android Artifact to Branch
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'actions@github.com'
          
          if [ -f "${{ github.workspace }}/android/app/build/outputs/bundle/release/app-release.aab" ]; then
            BRANCH_NAME="dev-builds/android-aab"
            ARTIFACT_PATH="${{ github.workspace }}/android/app/build/outputs/bundle/release/app-release.aab"
            COMMIT_MESSAGE="Signed Android AAB build from commit ${{ github.sha }}"
          else
            BRANCH_NAME="dev-builds/android-apk"
            ARTIFACT_PATH="${{ github.workspace }}/android/app/build/outputs/apk/debug/app-debug.apk"
            COMMIT_MESSAGE="Debug Android APK build from commit ${{ github.sha }}"
          fi
          
          ARTIFACT_FILENAME=$(basename "$ARTIFACT_PATH")
          echo "Found artifact: $ARTIFACT_PATH"

          mv "$ARTIFACT_PATH" "/tmp/$ARTIFACT_FILENAME"

          git checkout --orphan "$BRANCH_NAME"
          git rm -rf .
          git clean -fdx
          
          mv "/tmp/$ARTIFACT_FILENAME" .
          git add "$ARTIFACT_FILENAME"
          git commit -m "$COMMIT_MESSAGE"
          git push --force origin "$BRANCH_NAME"

  # Job 5: Build the native iOS App.
  build_ios:
    name: Build iOS App
    needs: build_web
    runs-on: macos-latest # iOS builds MUST run on a macOS machine.
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate package-lock.json
        run: npm install --package-lock-only --ignore-scripts

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm install

      - name: Download web assets artifact
        uses: actions/download-artifact@v4
        with:
          name: web-assets
          path: www

      - name: Add Capacitor iOS platform
        run: npx capacitor add ios

      - name: Inject native plugin source files
        run: npm run inject:native

      - name: Sync Capacitor project (discovers plugin)
        run: npx capacitor sync ios

      - name: Configure native project (manifests/gradle)
        run: npm run configure:project

      - name: Update CocoaPods repositories
        run: pod repo update
        working-directory: ios/App

      - name: Install CocoaPods
        run: pod install
        working-directory: ios/App

      - name: Build iOS App (Archive)
        run: |
          set -o pipefail && xcodebuild -workspace ios/App/App.xcworkspace \
            -scheme App \
            -configuration Release \
            -archivePath $PWD/ios/App/App.xcarchive \
            archive CODE_SIGN_IDENTITY="" CODE_SIGNING_REQUIRED=NO
        env:
          APPLE_DEVELOPMENT_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

      - name: Push iOS Archive to Branch
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'actions@github.com'
          
          BRANCH_NAME="dev-builds/ios-app"
          
          echo "Zipping the iOS archive..."
          zip -r App.xcarchive.zip ios/App/App.xcarchive
          
          ARTIFACT_PATH="App.xcarchive.zip"
          ARTIFACT_FILENAME=$(basename "$ARTIFACT_PATH")
          
          mv "$ARTIFACT_PATH" "/tmp/$ARTIFACT_FILENAME"
          
          git checkout --orphan "$BRANCH_NAME"
          
          git rm -rf .
          git clean -fdx
          
          mv "/tmp/$ARTIFACT_FILENAME" .
          git add "$ARTIFACT_FILENAME"
          git commit -m "iOS App Archive from commit ${{ github.sha }}"
          git push --force origin "$BRANCH_NAME"
